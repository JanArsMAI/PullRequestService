# PullRequestService

## **Сервис назначения ревьюеров для Pull Request’ов**

Внутри команды требуется единый микросервис, который автоматически назначает ревьюеров на Pull Request’ы (PR), а также позволяет управлять командами и участниками. Взаимодействие происходит исключительно через HTTP API.


## **Инструкция по запуску**
1. В корне проекта должен находиться `.env` файл, который задаёт конфигурацию приложения, в файле `.env-example` содержится пример конфигурации для запуска приложения. Пример:
```
POSTGRES_USER=postgres
POSTGRES_PASSWORD=1234
POSTGRES_DB=pr_service
POSTGRES_HOST=db
POSTGRES_PORT=5432
DB_SSL=disable
CONFIG_PATH=/app/config/config.yaml
```
2. Также нужно задать конфигурацию приложению в `config/config.yaml`, там можно настроить порт запуска, а также уровень логгирования(debug или info), в этой же папке имеется config-example.yaml:
```
app:
  port: 8080
logging:
  level: info #можно поставить уровень логирования debug
```
3. Можно запустить unit-тесты application слоя командой: ```go test -v  ./internal/application/tests/...```
4. Запуск линтера: ```golangci-lint run```
5. Генерация swagger документации по API: ```swag init -g ./cmd/main.go```
6. Запуск сервиса через Docker: ```docker compose up -d --build ``` (если вдруг будет проблема при скачивании модуля goose для миграции, то нужно запустить ещё раз, скорее всего, проблема с соединением при установке пакета)
7. Теперь сервис доступен на порту 8080, а БД запускается на 5433. Документацию для тестирования API можно найти по ссылке:
`http://localhost:8080/swagger/index.html#/`
8. Выключение сервиса: ```docker compose down```

## **Условие задачи**
Необходимо реализовать сервис, который назначает ревьюеров на PR из команды автора, позволяет выполнять переназначение ревьюверов и получать список PR’ов, назначенных конкретному пользователю, а также управлять командами и активностью пользователей. После merge PR изменение состава ревьюверов запрещено.
* Используйте этот API (OpenAPI-спецификация будет предоставлена отдельным файлом — `openapi.yaml`).
* Объём данных умеренный (до 20 команд и до 200 пользователей), RPS — 5, SLI времени ответа — 300 мс, SLI успешности — 99.9%.
* Пользователь с `isActive = false` не должен назначаться на ревью.
* Операция merge должна быть **идемпотентной** — повторный вызов не приводит к ошибке и возвращает актуальное состояние PR.
* Сервис и его зависимости должны подниматься командой **docker-compose up**. Если решение предусматривает миграции, они также должны применяться при выполнении этой команды. Сервис должен быть доступен на порту 8080.
* Учтите, что соблюдение условий по поднятию сервиса ускорит и упростит проверку вашей работы наставниками.
## **Реализованные Дополнительные задания**
* Добавить простой эндпоинт статистики (например, количество назначений по пользователям и/или по PR).
* Добавить метод массовой деактивации пользователей команды и безопасную переназначаемость открытых PR.
* Описать конфигурацию линтера(выбран `golangci-lint`, его конфигурация в файле `.golangci.yml` ).
## **Общие вводные**

**Пользователь (User)** — участник команды с уникальным идентификатором, именем и флагом активности `isActive`.

**Команда (Team)** — группа пользователей с уникальным именем.

**Pull Request (PR)** — сущность с идентификатором, названием, автором, статусом `OPEN|MERGED`и списком назначенных ревьюверов (до 2).

1. При создании PR автоматически назначаются **до двух** активных ревьюверов из **команды автора**, исключая самого автора.
2. Переназначение заменяет одного ревьювера на случайного **активного** участника **из команды заменяемого** ревьювера.
3. После `MERGED` менять список ревьюверов **нельзя**.
4. Если доступных кандидатов меньше двух, назначается доступное количество (0/1).


## **Решение задачи**
Для реализации сервиса был выбран язык Go, а в качестве СУБД PostgreSQL, в качестве логгера используется `zap`, уровень логирования настраивается через `config.yaml`. Приложение построено на принципах ddd архитектуры - разделения приложения на слои presentation(ручки и работа с API), application(бизнес логика), repo(работа с БД). Такое построение приложения упрощает разработку, тестирование и выявление ошибок. 
### **API слой**
Внутри presentation слоя реализована логика API, в качестве удобного пакета был выбран `gin`, каждя ручка покрыта swagger документацией. Для проверки доступа используются `CorsMiddleware` - метод, проверяющий источник запроса, `UserMiddleware` - проверка пользователя, `AdminMiddleware` - проверка администратора. Важно, что формат токена следующий: если пользователь admin - то нужно в качестве токена передавать `admin`, а если пользователь с ID - u1, то токен должен быть `u1`, для упрощения разработки и логики было выбрано такое решение. В местах проверки токена должен быть поход по gRPC на микросервис авторизации, однако раз его нет, то допустим такое упрощение в Middleware. 
Для безопасности и ограничения доступа существует 2 вида токенов доступа: Admin и User.  В API доступны следующие ручки:
1. ```team/add``` - Создание новой команды, можно как создавать новых пользователей, так и добавлять уже существующих. Если пользователь находится в другой команде и на нём висят PR, то они автоматически переназначаются на других членов его старой команды, а сам пользователь перезодит в созданную команду. Если команда с таким именем создана, то выбрасывается соответствующее сообщение. Пример тела запроса:
```
{
  "members": [
    {"is_active": true, "user_id": "u1", "username": "user1"},
    {"is_active": true, "user_id": "u2", "username": "user2"},
    {"is_active": true, "user_id": "u3", "username": "user3"},
    {"is_active": true, "user_id": "u4", "username": "user4"},
    {"is_active": true, "user_id": "u5", "username": "user5"},
    {"is_active": true, "user_id": "u6", "username": "user6"},
    {"is_active": true, "user_id": "u7", "username": "user7"},
    {"is_active": true, "user_id": "u8", "username": "user8"},
    {"is_active": true, "user_id": "u9", "username": "user9"},
    {"is_active": true, "user_id": "u10", "username": "user10"}
  ],
  "team_name": "Team10"
}
```
Токен: `admin`

2. `team/get` - Возвращает информацию о команде и её участниках. Доступ разрешён только для участников команды или администратора - это условие позволяет сделать сокрытие состава команды от других участников из других команд. Пример query параметра:`team_name =   Team10`, а в качестве токена можно указать `u5` или `admin`
3. `/users/setIsActive` - изменение активности пользователя, разрешается пользоваться только администратору. Если у пользователя есть текущие Pull Requests и его деактивируют, то активные PR переназначаются на других членов команды(или же ставится флаг need_more_reviewers). Если пользователя наоборот активируют, и у его команды есть открытые PR, где не хватает ревьюеров, то эти PR назначаются на активированного пользователя. Пример запроса:
```
{
  "is_active": false,
  "user_id": "u10"
}
```
токен - `admin`

4. `/users/getReview` - Получение всех PR пользователя, как открытых, так и закрытых. Пример query параметра: `user_id = u10`, токен - `u5`
5. `/pullRequest/create` - создание Pull Request, создавать может только администратор. Если PR с таким id уже создан, то ему придёт соответствующее сообщение, пример запроса: 
```
{
  "author_id": "u10",
  "pull_request_id": "PR1",
  "pull_request_name": "first"
}
```
 токен - `admin`
6. `/pullRequest/merge` - переводит PR в статус `MERGED`, если он ещё открыт. Сделать эту операцию может только назначенный ревьюер. Остальные пользователи, автор не могут сделать это. Если PR не найден или в состоянии `MERGED`,то возвращается информация по этому PR. Пример тела запроса:
```
{
  "pull_request_id": "PR1"
}
```
токен ставится тот, который соответсвует пользователю - Ревьюеру. 
7. `/pullRequest/reassign` - переназначает ревьюера для PR, админ выбирает пользователя, которого нужно заменить, и происходит автоматическая замена ревьюера. Если PR уже имеет статус MERGED, то переназначение не происходит. В ответе видно, на кого произошло переназначение. Пример тела запроса:
```
{
  "pull_request_id": "PR1",
  "old_reviewer_id": "u4"
}
```
токен - `admin`
8. `deactivate/use` - Дополнительная ручка, которая используется для массовой деактивации пользователей. Если у пользователей есть открытые PR, то происходит переназначение, делать переназначение может только администратор. Пример тела запроса:
```
{
  "team_name": "Team10",
  "user_ids": [
    "u1",
    "u2"
  ]
}
```
9. `stats/get` - Дополнительно реализованная ручка статистики, показывающее все PR и количество ревьюеров, и всех ревьюеров и их количество PR, пример ответа:
```
{
  "by_user": {
    "u2": 1,
    "u7": 1
  },
  "by_pr": {
    "PR": 1
  }
}
```

### **Application слой**
Этот слой выступает как связующий между Presentation и Repo слоем, в нём происходит валидация данных, обработка ошибок с repo, и тут реализована вся бизнес логика приложения. Основные методы, которые взаимодействуют с Presentation слоем покрыты unit-тестами. 

### **Repo слой и структура БД**
В качестве СУБД был выбран PostgreSQL, для взаимодействия был выбран пакет `database/sqlx`, в качестве инструмента миграций был выбран `goose`. 
База данных состоит из 4 таблиц, вот структура таблиц:
```
CREATE TABLE IF NOT EXISTS teams (
    id SERIAL PRIMARY KEY,
    team_name VARCHAR(100) NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS users (
    user_id VARCHAR(50) NOT NULL,
    username VARCHAR(100) NOT NULL,
    team_id INT NOT NULL REFERENCES teams(id) ON DELETE CASCADE,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    PRIMARY KEY (user_id)
);

CREATE TABLE IF NOT EXISTS pull_requests (
    pull_request_id VARCHAR(50) PRIMARY KEY,
    pull_request_name VARCHAR(200) NOT NULL,
    author_id VARCHAR(50) NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    status VARCHAR(10) NOT NULL CHECK (status IN ('OPEN','MERGED')),
    need_more_reviewers BOOLEAN NOT NULL DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    merged_at TIMESTAMP WITH TIME ZONE
);

CREATE TABLE IF NOT EXISTS pull_request_reviewers (
    pull_request_id VARCHAR(50) NOT NULL REFERENCES pull_requests(pull_request_id) ON DELETE CASCADE,
    reviewer_id VARCHAR(50) NOT NULL REFERENCES users(user_id) ON DELETE CASCADE,
    assigned_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (pull_request_id, reviewer_id)
);

CREATE INDEX idx_users_team ON users(team_id);
CREATE INDEX idx_pr_reviewers_user ON pull_request_reviewers(reviewer_id);
CREATE INDEX idx_pr_author_status ON pull_requests(author_id, status);
```
Для ускорения поиска по БД используются индексы по ключевым полям таблиц. 

## Итог
Реализован сервис Pull Request, который соответсвует техническому заданию, предоставленным заказчиком. Также было реализовано 3 дополнительных задания: 
* Добавить простой эндпоинт статистики (например, количество назначений по пользователям и/или по PR).
* Добавить метод массовой деактивации пользователей команды и безопасную переназначаемость открытых PR.
* Описать конфигурацию линтера(выбран `golangci-lint`, его конфигурация в файле `.golangci.yml` ).